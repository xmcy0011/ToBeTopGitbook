# 间隙锁案例

## 数据库准备

1. MySQL 8 相比 MySQL 5.7 在锁分析的功能上更强大，故本文使用 MySQL 8 进行分析，容器启动快捷命令：

```bash
$ docker pull mysql:latest
$ docker run --name mysql8 -e MYSQL_ROOT_PASSWORD=123456 -dp13306:3306 mysql:latest
$ mysql -uroot -p -h 127.0.0.1 -P 13306
```

2. 请确认隔离级别是可重复读（Repeatable Read），间隙锁只在该级别下使用。

## 准备

创建如下表：

```sql
CREATE TABLE `test_gap_lock` (
  `id` int NOT NULL AUTO_INCREMENT,
  `c` int DEFAULT NULL,
  `d` int DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_c` (`c`)
) ENGINE=InnoDB;
```

其中，id 列是主键，c 是普通索引，d 没有索引。

准备如下初始数据：

```sql
insert into test_gap_lock values
(5, 5, 5),
(10, 10, 10),
(15, 15, 15),
(20, 20, 20),
(25, 25, 25);
```

上述有7个区间：

```bash
（-∞，5]（5，10]（10，15]（15，20]（20，25]（25，+supernum]
```

其中圆括号表示排除区间端点，方括号表示包含端点（左开右闭）。

## 案例1：简单案例

当有如下事务A和事务B时，事务A会对数据库表增加（10，15）这个区间锁，这时insert id = 12 的数据的时候就会因为区间锁（10，15）而被锁住无法执行。

> PS：因为 id=11 的记录不存在，故加的是间隙锁（10，15），否则是间隙锁+记录锁（10,15]，也就是 NextKey 锁，即临键锁。

| 步骤 | 事务A | 事务B |
| - | - | - |
| 1 | begin;<br />select * from test_gap_lock where id = 11 for update;	| |
| 2 | | insert into test_gap_lock values(12,12,12);<br /><strong style="color:red">blocked;</strong> |
| 3 | commit | |

## 案例2：间隙锁死锁

不同于写锁相互之间是互斥的原则，间隙锁之间不是互斥的（[官方文档: InnoDB 锁定](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks)），如果一个事务A获取到了（5,10）之间的间隙锁，另一个事务B也可以获取到（5,10）之间的间隙锁，这时就可能会发生死锁问题。

> PS：间隙锁2边都是开，如 (5,10)。而临键锁左开右闭，如（5,10]，请注意区分。

如下：
- 事务A获取到（5,10）间隙锁，不允许其他事务的 DML 操作
- 事务B也获取到了间隙锁（5,10），此时事务 B 执行 insert 操作将被阻塞
- 事务A可以继续执行，当其准备执行 insert 操作时，也将导致阻塞，最终 A 和 B 互等，A 事务被 Kill，报死锁错误

| 步骤 | 事务A | 事务B |
|-|-|-|
| 1 | begin;<br />select * from test_gap_lock where id=9 for update; | |
| 2 | | begin;<br />select * from test_gap_lock where id=6 for update;|
| 3 | | insert into test_gap_lock values(7,7,7);<br /><strong style="color:red">blocked;</strong>
| 4 | insert into test_gap_lock values(7,7,7);<br /><strong style="color:red">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong> | |

1）先执行事务 A 的 select 语句，因为不存在 id=9 的记录，故只锁定 (5,10) 的间隙，即加的是间隙锁（X,GAP）：

```bash
$ select ENGINE_TRANSACTION_ID,EVENT_ID,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA from performance_schema.data_locks;
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
| ENGINE_TRANSACTION_ID | EVENT_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
|                  1875 |       36 | NULL       | TABLE     | IX        | GRANTED     | NULL      |
|                  1875 |       36 | PRIMARY    | RECORD    | X,GAP     | GRANTED     | 10        |
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
```

2）执行 B 的 select，因为不存在 id=9 的记录，故只锁定 (5,10) 的间隙，也只加了间隙锁（X,GAP），并且没有阻塞说明可以重复获取间隙锁（间隙锁只是为了防止 insert，可以重复获取是合理的）：

```bash
select ENGINE_TRANSACTION_ID,EVENT_ID,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA from performance_schema.data_locks;
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
| ENGINE_TRANSACTION_ID | EVENT_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
|                  1876 |       39 | NULL       | TABLE     | IX        | GRANTED     | NULL      |
|                  1876 |       39 | PRIMARY    | RECORD    | X,GAP     | GRANTED     | 10        |
+-----------------------+----------+------------+-----------+-----------+-------------+-----------+
```

且意向锁 IX 和 IX 兼容，故事务 B 更不会阻塞，表级锁类型兼容性总结在以下矩阵中：

|  | X | IX | S | IS |
|-|-|-|-| - |
|X | 冲突 | 冲突| 冲突 | 冲突 |
|IX | 冲突 | 兼容的 | 冲突 | 兼容的 |
|S | 冲突 | 冲突 | 兼容的 | 兼容的 |
|IS | 冲突 | 兼容的 | 兼容的| 兼容的 |

3）执行步骤3事务 B 的 insert，事务 B 被阻塞，LOCK_MODE 显示 X,GAP,INSERT_INTENTION（插入意向锁）

```bash
$ select ENGINE_TRANSACTION_ID,EVENT_ID,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA from performance_schema.data_locks;
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | EVENT_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE              | LOCK_STATUS | LOCK_DATA |
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
|                  1875 |       37 | PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | WAITING     | 10        |
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
```

4）如果我们执行事务 A 的 Insert 语句，会立马死锁：

```sql
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

查看 MySQL 日志（8.0）：

```sql
------------------------
LATEST DETECTED DEADLOCK
------------------------
2024-03-08 08:50:44 140294189299456
*** (1) TRANSACTION:
TRANSACTION 1904, ACTIVE 243 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1128, 3 row lock(s)
MySQL thread id 34, OS thread handle 140294170400512, query id 924 172.17.0.1 root update
insert into test_gap_lock values(7,7,7)

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 3 page no 4 n bits 80 index PRIMARY of table `go-cloud-driver`.`test_gap_lock` trx id 1904 lock_mode X locks gap before rec
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000072f; asc      /;;
 2: len 7; hex 8100000124011d; asc     $  ;;
 3: len 4; hex 8000000a; asc     ;;
 4: len 4; hex 8000000a; asc     ;;

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 3 page no 4 n bits 80 index PRIMARY of table `go-cloud-driver`.`test_gap_lock` trx id 1904 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000072f; asc      /;;
 2: len 7; hex 8100000124011d; asc     $  ;;
 3: len 4; hex 8000000a; asc     ;;
 4: len 4; hex 8000000a; asc     ;;


*** (2) TRANSACTION:
TRANSACTION 1903, ACTIVE 281 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)
MySQL thread id 33, OS thread handle 140294171457280, query id 925 172.17.0.1 root update
insert into test_gap_lock values(7,7,7)

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 3 page no 4 n bits 80 index PRIMARY of table `go-cloud-driver`.`test_gap_lock` trx id 1903 lock_mode X locks gap before rec
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000072f; asc      /;;
 2: len 7; hex 8100000124011d; asc     $  ;;
 3: len 4; hex 8000000a; asc     ;;
 4: len 4; hex 8000000a; asc     ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 3 page no 4 n bits 80 index PRIMARY of table `go-cloud-driver`.`test_gap_lock` trx id 1903 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000072f; asc      /;;
 2: len 7; hex 8100000124011d; asc     $  ;;
 3: len 4; hex 8000000a; asc     ;;
 4: len 4; hex 8000000a; asc     ;;

*** WE ROLL BACK TRANSACTION (2)
```

- 事务 B 执行的 sql 语句为：insert into test_gap_lock values(7,7,7) ，持有 index PRIMARY 的间隙锁（lock_mode X locks gap before rec），等待获取 index PRIMARY 的插入意向锁（lock_mode X locks gap before rec insert intention waiting）
- 事务 A 执行的 sql 语句为：insert into test_gap_lock values(7,7,7)，持有 index PRIMARY 的间隙锁（lock_mode X locks gap before rec），等待获取 index PRIMARY 的插入意向锁（lock_mode X locks gap before rec insert intention waiting）

我们看到事务 A 和 事务 B 同时持有间隙锁，双方同时执行 insert 后，互相等待对方释放间隙锁，这是不可能的，因为此时2个事务都进入了 block 状态，所以导致了死锁，其中一个事务被回滚。

5）事务A被回滚后，事务 B 继续执行，插入意向锁的状态由 WAITING 变成 GRANTED，代表获取到了锁。

```sql
$ select ENGINE_TRANSACTION_ID,EVENT_ID,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA from performance_schema.data_locks;
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
| ENGINE_TRANSACTION_ID | EVENT_ID | INDEX_NAME | LOCK_TYPE | LOCK_MODE              | LOCK_STATUS | LOCK_DATA |
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
|                  1875 |       37 | PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | GRANTED     | 10        |
+-----------------------+----------+------------+-----------+------------------------+-------------+-----------+
```

## 附录：案例2的间隙锁死锁如何解决？

上文演示的案例中，比较贴近于"不存在则插入，存在则返回的"场景，修改 SQL 如下：

```sql
select * from test_gap_lock where id=9 for update;
insert into test_gap_lock values(9,9,9);
```

所以，此时我们讨论的是，在可重复读级别下，不存在记录并发插入的死锁问题。

## 参考

- [官网文档：InnoDB Locking](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks)
- [官方文档：Phantom Rows（幻读）](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)
- [MYSQL（04）-间隙锁详解](https://www.jianshu.com/p/32904ee07e56)
- [MySQL 是怎么加锁的？](https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E4%BB%80%E4%B9%88-sql-%E8%AF%AD%E5%8F%A5%E4%BC%9A%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81)
- [记一次 innodb 间隙锁导致的死锁分析](https://priesttomb.github.io/%E6%8A%80%E6%9C%AF/2021/09/27/deadlock-in-innodb-on-delete-and-insert/)
- [MySQL锁系列（一）之锁的种类和概念](https://keithlan.github.io/2017/06/05/innodb_locks_1/)
